import { Component, OnInit, Input, OnChanges, SimpleChanges, Renderer2, ViewChildren, QueryList, AfterViewInit } from '@angular/core';
import { FreecellLayout } from '../freecell-layout';
import { toPercent } from '../common/math-utils';
import { suitFullNameOf, rankFullNameOf, CARD_NUM, playNameOf } from '../common/deck';
import { Dragger } from '../common/dragger';
import { Autoplay } from '../common/autoplay';
import { FreecellGame } from '../freecell-game';
import { KeyedElementDirective } from '../common/keyed-element.directive';
import { isMoveValid } from '../freecell-basis';

interface Place {
  style: {
    top: string,
    left: string,
    width: string,
    height: string,
    zIndex?: number,
    transform?: string,
   };
  classNames: { [key: string]: boolean };
}

function createFreecellPlaceholders(layout: FreecellLayout): Place[] {
  const basis = layout.basis;
  const W = layout.width;
  const H = layout.height;

  const width = toPercent(layout.itemWidth, W);
  const height = toPercent(layout.itemHeight, H);

  const placeholders: Place[] = [];
  for (let i = 0; i < basis.DESK_SIZE; i++) {
    const left = toPercent(layout.getX(i), W);
    const top = toPercent(layout.getY(i), H);

    const place: Place = {
      style: { left, top, width, height },
      classNames: { placeholder: true }
    };

    if (basis.isBase(i)) {
      place.classNames.base = true;
      place.classNames[suitFullNameOf(i - basis.BASE_START)] = true;
    } else if (basis.isCell(i)) {
      place.classNames.cell = true;
    } else if (basis.isPile(i)) {
      place.classNames.pile = true;
    }

    placeholders.push(place);
  }
  return placeholders;
}

function createFreecellCards(layout: FreecellLayout): Place[] {
  const basis = layout.basis;
  const W = layout.width;
  const H = layout.height;

  const width = toPercent(layout.itemWidth, W);
  const height = toPercent(layout.itemHeight, H);

  const cards: Place[] = [];
  for (let i = 0; i < basis.CARD_NUM; i++) {
    const left = toPercent(i, basis.CARD_NUM);
    const top = toPercent(0, H);

    const place: Place = {
      style: { left, top, width, height },
      classNames: { card: true, [rankFullNameOf(i)]: true, [suitFullNameOf(i)]: true  }
    };

    cards.push(place);
  }
  return cards;
}

const Transitions = ['transition_deal', 'transition_norm', 'transition_fast'] as const;
type Transition = typeof Transitions[number];
type TransitionMap = Partial<{ [key in Transition]: boolean }>;

function setTransition(classNames: TransitionMap, transition?: Transition) {
  for (const t of Transitions) {
    classNames[t] = t === transition;
  }
}

@Component({
  selector: 'app-playground',
  templateUrl: './playground.component.html',
  styleUrls: ['./playground.component.scss']
})
export class PlaygroundComponent implements OnInit, OnChanges, AfterViewInit {
  @Input()
  layout: FreecellLayout;

  @ViewChildren(KeyedElementDirective) children: QueryList<KeyedElementDirective>; // native elements generated by elements array
  elements: Place[] = []; // placeholders + cards
  spotCount = 0;
  cardCount = 0;

  @Input()
  deal: number;

  game: FreecellGame;

  private dragger: Dragger;
  private autoplay = new Autoplay(1000);

  constructor(private renderer: Renderer2) { }

  ngOnInit() {
  }

  ngOnChanges(changes: SimpleChanges) {
    if (changes.layout) {
      if (this.layout) {
        const placeholders = createFreecellPlaceholders(this.layout);
        const cards = createFreecellCards(this.layout);

        this.cardCount = cards.length;
        this.spotCount = placeholders.length;

        this.elements = placeholders.concat(cards);

        this.game = new FreecellGame(this.layout.basis);
      } else {
        this.cardCount = 0;
        this.spotCount = 0;
        this.elements = [];
        this.game = null;
      }
    }

    if (this.game) {
      this.onDeal();
    }
  }

  trackByIndex(index: number): number {
    return index;
  }

  getCardElement(cardIndex: number) {
    return this.elements[this.spotCount + cardIndex];
  }

  ngAfterViewInit() {
    console.log(this.children);
  }

  onDeal() {
    this.game.deal(this.deal);

    for (let i = 0; i < this.game.length; i++) {
      this.updateLine(i, 'transition_deal');
    }
  }

  onMouseDown(event: MouseEvent, index: number) {
    if (event.button !== 0) {
      return;
    }

    // console.log('Mousedown:', cardIndex);
    event.preventDefault();

    if (this.dragger || index < this.spotCount) {
      return;
    } else {
      const cardIndex = index - this.spotCount;
      const tableau = this.game.asTablaeu(cardIndex);

      this.dragger = new Dragger(event.screenX, event.screenY, this.renderer);
      this.onDragStart(tableau);
      this.dragger.onDrag = () => this.onDrag(tableau);
      this.dragger.onDragEnd = (ev) => {
        this.onDragEnd(tableau);

        const destination = this.findDestination(index, ev.clientX, ev.clientY);
        if (destination >= 0) {
          const srcLine = this.game.lineMap[index - this.spotCount];
          const dstLine = destination < this.spotCount ? destination : this.game.lineMap[destination - this.spotCount];
          if (srcLine !== dstLine) {
            this.playPath(this.game.getBestPath(tableau, dstLine));
          }
        }

        this.dragger = null;
      };
    }
  }

  playPath(path?: number[]) {
    if (path && path.length > 0) {
      const basis = this.game.basis;
      this.onCardMove(basis.toSource(path[0]), basis.toDestination(path[0]), 'transition_fast');
      if (path.length > 1) {
        path.reverse();
        path.pop();
        this.autoplay.play(() => {
          if (path.length > 0) {
            const move = path.pop();
            return this.onCardMove(basis.toSource(move), basis.toDestination(move),
              path.length > 0 ? 'transition_fast' : 'transition_norm')
              && path.length > 0;
          }
          return false;
        });
      }
    }
  }

  findDestination(source: number, clientX: number, clientY: number): number {
    let destination = -1;
    if (this.children) {
      this.children.forEach((item) => {
        const index: number = +item.key;
        if (index !== source) {
          const rc = item.nativeElement.getBoundingClientRect();
          if (rc.left <= clientX && clientX <= rc.right &&
            rc.top <= clientY && clientY <= rc.bottom) {
            console.log('Collision at: ' + index);
            destination = index;
          }
        }
      });
    }
    return destination;
  }

  onDragStart(tableau: number[]) {
    this.autoplay.stop();

    for (let i = 0; i < tableau.length; i++) {
      const card = this.elements[this.spotCount + tableau[i]];
      card.style.zIndex = CARD_NUM + i;
      card.classNames.dragged = true;
      setTransition(card.classNames);
    }
  }

  onDrag(tableau: number[]) {
    for (const c of tableau) {
      const card = this.elements[this.spotCount + c];
      card.style.transform = `translate(${this.dragger.deltaX}px, ${this.dragger.deltaY}px)`;
    }
  }

  onDragEnd(tableau: number[]) {
    for (const c of tableau) {
      const card = this.elements[this.spotCount + c];
      card.style.zIndex = this.game.spotMap[c];
      delete card.style.transform;
      delete card.classNames.dragged;
      setTransition(card.classNames, 'transition_fast');
    }
  }

  onCardMove(source: number, destination: number, transition: Transition) {
    if (this.game.moveCard(source, destination)) {
      this.updateLine(source, 'transition_fast');
      this.updateLine(destination, transition);
      return true;
    }
    return false;
  }

  updateLine(index: number, transition: Transition) {
    const W = this.layout.width;
    const H = this.layout.height;
    const line = this.game.lineAt(index);

    for (let i = 0; i < line.length; i++) {
      const cardIndex = line[i];
      const card = this.getCardElement(cardIndex);
      card.style.left = toPercent(this.layout.getCardX(index, i, line.length), W);
      card.style.top = toPercent(this.layout.getCardY(index, i, line.length), H);
      card.style.zIndex = i;

      setTransition(card.classNames, transition);
    }
  }
}
